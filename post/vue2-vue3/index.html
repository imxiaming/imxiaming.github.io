<!DOCTYPE html>

















<html lang="zh">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>vue2与vue3的区别 - 夏明</title>

  
  
  <meta name="description" content="vue2和vue3双向数据绑定原理发生了改变 vue2的双向数据绑定是利用ES5的一个API Object.definePropert()对数据进行劫持结合发布订阅模式的方式来实现的。
vue3中使用了es6的ProxyAPI对数据代理。
 相比于vue2.x，使用proxy的优势如下
 defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化   Vue3支持碎片(Fragments) 就是说在组件可以拥有多个根节点。
vue2 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; vue3 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;/div&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/template&gt; Composition API Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）
 旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。
 vue2 export default { props: { title: String }, data () { return { username: &#39;&#39;, password: &#39;&#39; } }, methods: { login () { // 登陆方法 } }, components: { &#34;buttonComponent&#34;: btnComponent }, computed: { fullName() { return this." />
  <meta name="author" content="夏明" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://xiaming.com.cn/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://xiaming.com.cn/an-old-hope.min.css" />
  <script
    defer
    src="https://xiaming.com.cn/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://xiaming.com.cn/theme.png" />

  
  <link rel="preload" as="image" href="https://xiaming.com.cn/twitter.svg" />
  
  <link rel="preload" as="image" href="https://xiaming.com.cn/github.svg" />
  
  <link rel="preload" as="image" href="https://xiaming.com.cn/instagram.svg" />
  

  
  <link rel="icon" href="https://xiaming.com.cn/favicon.ico" />
  <link rel="apple-touch-icon" href="https://xiaming.com.cn/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.96.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="vue2与vue3的区别" />
<meta property="og:description" content="vue2和vue3双向数据绑定原理发生了改变 vue2的双向数据绑定是利用ES5的一个API Object.definePropert()对数据进行劫持结合发布订阅模式的方式来实现的。
vue3中使用了es6的ProxyAPI对数据代理。
 相比于vue2.x，使用proxy的优势如下
 defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化   Vue3支持碎片(Fragments) 就是说在组件可以拥有多个根节点。
vue2 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; vue3 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;/div&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/template&gt; Composition API Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）
 旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。
 vue2 export default { props: { title: String }, data () { return { username: &#39;&#39;, password: &#39;&#39; } }, methods: { login () { // 登陆方法 } }, components: { &#34;buttonComponent&#34;: btnComponent }, computed: { fullName() { return this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiaming.com.cn/post/vue2-vue3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-06-28T00:00:00+00:00" />


  
  <meta itemprop="name" content="vue2与vue3的区别">
<meta itemprop="description" content="vue2和vue3双向数据绑定原理发生了改变 vue2的双向数据绑定是利用ES5的一个API Object.definePropert()对数据进行劫持结合发布订阅模式的方式来实现的。
vue3中使用了es6的ProxyAPI对数据代理。
 相比于vue2.x，使用proxy的优势如下
 defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化   Vue3支持碎片(Fragments) 就是说在组件可以拥有多个根节点。
vue2 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; vue3 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;/div&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/template&gt; Composition API Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）
 旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。
 vue2 export default { props: { title: String }, data () { return { username: &#39;&#39;, password: &#39;&#39; } }, methods: { login () { // 登陆方法 } }, components: { &#34;buttonComponent&#34;: btnComponent }, computed: { fullName() { return this."><meta itemprop="datePublished" content="2021-06-28T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-06-28T00:00:00+00:00" />
<meta itemprop="wordCount" content="678">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="vue2与vue3的区别"/>
<meta name="twitter:description" content="vue2和vue3双向数据绑定原理发生了改变 vue2的双向数据绑定是利用ES5的一个API Object.definePropert()对数据进行劫持结合发布订阅模式的方式来实现的。
vue3中使用了es6的ProxyAPI对数据代理。
 相比于vue2.x，使用proxy的优势如下
 defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化   Vue3支持碎片(Fragments) 就是说在组件可以拥有多个根节点。
vue2 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; vue3 &lt;template&gt; &lt;div class=&#39;form-element&#39;&gt; &lt;/div&gt; &lt;h2&gt; {{ title }} &lt;/h2&gt; &lt;/template&gt; Composition API Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）
 旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。
 vue2 export default { props: { title: String }, data () { return { username: &#39;&#39;, password: &#39;&#39; } }, methods: { login () { // 登陆方法 } }, components: { &#34;buttonComponent&#34;: btnComponent }, computed: { fullName() { return this."/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://xiaming.com.cn/">夏明</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/"
      target="_blank"
    ></a>
    
    <a
      class="instagram"
      style="--url: url(./instagram.svg)"
      href="https://instagram.com/"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2021年6月28日</time>
      
      <span>夏明</span>
      
    </p>
    <h1>vue2与vue3的区别</h1>
  </header>
  <section class="post-content"><h2 id="vue2和vue3双向数据绑定原理发生了改变">vue2和vue3双向数据绑定原理发生了改变</h2>
<p>vue2的双向数据绑定是利用ES5的一个<code>API Object.definePropert()</code>对数据进行劫持结合发布订阅模式的方式来实现的。</p>
<p>vue3中使用了es6的<code>Proxy</code>API对数据代理。</p>
<blockquote>
<p>相比于vue2.x，使用proxy的优势如下</p>
<ol>
<li>defineProperty只能监听某个属性，不能对全对象监听</li>
<li>可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</li>
<li>可以监听数组，不用再去单独的对数组做特异性操作，vue3.x可以检测到数组内部数据的变化</li>
</ol>
</blockquote>
<h2 id="vue3支持碎片fragments">Vue3支持碎片(Fragments)</h2>
<p>就是说在组件可以拥有多个根节点。</p>
<h3 id="vue2">vue2</h3>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;div class=&#39;form-element&#39;&gt;
  &lt;h2&gt; {{ title }} &lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><h3 id="vue3">vue3</h3>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;div class=&#39;form-element&#39;&gt;
  &lt;/div&gt;
   &lt;h2&gt; {{ title }} &lt;/h2&gt;
&lt;/template&gt;
</code></pre><h2 id="composition-api">Composition API</h2>
<p>Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）</p>
<blockquote>
<p>旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。</p>
</blockquote>
<h3 id="vue2-1">vue2</h3>
<pre tabindex="0"><code>export default {
  props: {
    title: String
  },
  data () {
    return {
      username: &#39;&#39;,
      password: &#39;&#39;
    }
  },
  methods: {
    login () {
      // 登陆方法
    }
  },
  components: {
            &#34;buttonComponent&#34;: btnComponent
        },
  computed: {
	  fullName() {
	    return this.firstName + &#34; &#34; + this.lastName;     
	  }
  }
}
</code></pre><h3 id="vue3-1">vue3</h3>
<pre tabindex="0"><code>export default {
  props: {
    title: String
  },
  setup () {
    const state = reactive({ //数据
      username: &#39;&#39;,
      password: &#39;&#39;,
      lowerCaseUsername: computed(() =&gt; state.username.toLowerCase()) //计算属性
    })
     //方法
    const login = () =&gt; {
      // 登陆方法
    }
    return { 
      login,
      state
    }
  }
}
</code></pre><h2 id="建立数据-data">建立数据 data</h2>
<h3 id="vue2---这里把数据放入data属性中">Vue2 - 这里把数据放入data属性中</h3>
<pre tabindex="0"><code>export default {
  props: {
    title: String
  },
  data () {
    return {
      username: &#39;&#39;,
      password: &#39;&#39;
    }
  }
}
</code></pre><p>在Vue3.0，我们就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。</p>
<p>使用以下三步来建立反应性数据:</p>
<ol>
<li>
<p>从vue引入reactive</p>
</li>
<li>
<p>使用reactive()方法来声名我们的数据为响应性数据</p>
</li>
<li>
<p>使用setup()方法来返回我们的响应性数据，从而我们的template可以获取这些响应性数据</p>
</li>
</ol>
<pre tabindex="0"><code>import { reactive } from &#39;vue&#39;

export default {
  props: {
    title: String
  },
  setup () {
    const state = reactive({
      username: &#39;&#39;,
      password: &#39;&#39;
    })

    return { state }
  }
}
</code></pre><p>template使用，可以通过state.username和state.password获得数据的值。</p>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt; {{ state.username }} &lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><h2 id="生命周期钩子--lifecyle-hooks">生命周期钩子 — Lifecyle Hooks</h2>
<pre tabindex="0"><code>Vue2--------------vue3
beforeCreate  -&gt; setup()
created       -&gt; setup()
beforeMount   -&gt; onBeforeMount
mounted       -&gt; onMounted
beforeUpdate  -&gt; onBeforeUpdate
updated       -&gt; onUpdated
beforeDestroy -&gt; onBeforeUnmount
destroyed     -&gt; onUnmounted
activated     -&gt; onActivated
deactivated   -&gt; onDeactivated
</code></pre><ol>
<li>
<p>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method</p>
</li>
<li>
<p>onBeforeMount() : 组件挂载到节点上之前执行的函数。</p>
</li>
<li>
<p>onMounted() : 组件挂载完成后执行的函数。</p>
</li>
<li>
<p>onBeforeUpdate(): 组件更新之前执行的函数。</p>
</li>
<li>
<p>onUpdated(): 组件更新完成之后执行的函数。</p>
</li>
<li>
<p>onBeforeUnmount(): 组件卸载之前执行的函数。</p>
</li>
<li>
<p>onUnmounted(): 组件卸载完成后执行的函数</p>
</li>
</ol>
<p>若组件被<code>&lt;keep-alive&gt;</code>包含，则多出下面两个钩子函数。</p>
<ol>
<li>
<p>onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。</p>
</li>
<li>
<p>onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。</p>
</li>
</ol>
<h2 id="父子传参不同setup-函数特性">父子传参不同，setup() 函数特性</h2>
<h3 id="总结">总结</h3>
<p>1、setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）</p>
<p>2、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数</p>
<p>3、执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）</p>
<p>4、与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用)</p>
<p>5、使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态</p>
<h3 id="注意事项">注意事项</h3>
<p>1、setup函数中不能使用this。Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）</p>
<p>2、setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。</p>
<p>如果需要解构 prop，可以通过使用 setup 函数中的<code>toRefs</code>来完成此操作：</p>
<h4 id="父传子props">父传子，props</h4>
<pre tabindex="0"><code>import { toRefs } from &#39;vue&#39;
 
setup(props) {
	const { title } = toRefs(props)
 
	console.log(title.value)
	 onMounted(() =&gt; {
      console.log(&#39;title: &#39; + props.title)
    })

}
</code></pre><h4 id="子传父事件---emitting-events">子传父，事件 - Emitting Events</h4>
<p>举例，现在我们想在点击提交按钮时触发一个login的事件。</p>
<p>在 Vue2 中我们会调用到this.$emit然后传入事件名和参数对象。</p>
<pre tabindex="0"><code>login () {
      this.$emit(&#39;login&#39;, {
        username: this.username,
        password: this.password
      })
 }
</code></pre><p>在setup()中的第二个参数content对象中就有emit，这个是和this.$emit是一样的。那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。</p>
<p>然后我们在login方法中编写登陆事件</p>
<p>另外：context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构</p>
<pre tabindex="0"><code>setup (props, { attrs, slots, emit }) {
    // ...
    const login = () =&gt; {
      emit(&#39;login&#39;, {
        username: state.username,
        password: state.password
      })
    }

    // ...
}
</code></pre><p>3、setup()内使用响应式数据时，需要通过.value获取</p>
<pre tabindex="0"><code>import { ref } from &#39;vue&#39;
 
const count = ref(0)
console.log(count.value) // 0
</code></pre><p>4、从 setup() 中返回的对象上的 property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 .value</p>
<p>5、setup函数只能是同步的不能是异步的</p>
<h2 id="vue3-teleport瞬移组件">vue3 Teleport瞬移组件</h2>
<p>Teleport一般被翻译成瞬间移动组件,实际上是不好理解的.我把他理解成&quot;独立组件&quot;,他可以拿你写的组件挂载到任何你想挂载的DOM上,所以是很自由很独立的</p>
<p>以一个例子来看:编写一个弹窗组件</p>
<pre tabindex="0"><code>&lt;template&gt;
&lt;teleport to=&#34;#modal&#34;&gt;
  &lt;div id=&#34;center&#34; v-if=&#34;isOpen&#34;&gt;
    &lt;h2&gt;&lt;slot&gt;this is a modal&lt;/slot&gt;&lt;/h2&gt;
    &lt;button @click=&#34;buttonClick&#34;&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/teleport&gt;
&lt;/template&gt;
&lt;script lang=&#34;ts&#34;&gt;

export default {
  props: {
    isOpen: Boolean,
  },
  emits: {
    &#39;close-modal&#39;: null
  },
  setup(props, context) {
    const buttonClick = () =&gt; {
      context.emit(&#39;close-modal&#39;)
    }
    return {
      buttonClick
    }
  }
}
&lt;/script&gt;
&lt;style&gt;
  #center {
    width: 200px;
    height: 200px;
    border: 2px solid black;
    background: white;
    position: fixed;
    left: 50%;
    top: 50%;
    margin-left: -100px;
    margin-top: -100px;
  }
&lt;/style&gt;
</code></pre><p>在app.vue中使用的时候跟普通组件调用是一样的</p>
<pre tabindex="0"><code>&lt;template&gt;
&lt;div id=&#34;app&#34;&gt;
  &lt;img alt=&#34;Vue logo&#34; src=&#34;./assets/logo.png&#34;&gt;
  &lt;HelloWorld msg=&#34;Welcome to Your Vue.js App&#34;/&gt;
  &lt;HooksDemo&gt;&lt;/HooksDemo&gt;
  &lt;button @click=&#34;openModal&#34;&gt;Open Modal&lt;/button&gt;&lt;br/&gt;
&lt;modal :isOpen=&#34;modalIsOpen&#34; @close-modal=&#34;onModalClose&#34;&gt; My Modal !!!!&lt;/modal&gt;
&lt;/div&gt;
  
&lt;/template&gt;
&lt;script&gt;
import HelloWorld from &#39;./components/HelloWorld.vue&#39;
import HooksDemo from &#39;./components/HooksDemo.vue&#39;
import Modal from &#39;./components/Modal.vue&#39;
import{ref} from &#39;vue&#39;
export default {
  name: &#39;App&#39;,
  components: {
    HelloWorld,
    HooksDemo,
    Modal
  },
  setup() {
    const modalIsOpen = ref(false)
    const openModal = () =&gt; {
      modalIsOpen.value = true
    }
    const onModalClose = () =&gt; {
      modalIsOpen.value = false
    }
    return {
      modalIsOpen,
      openModal,
      onModalClose
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;
</code></pre><p>要是在app.vue文件中使用的时候,modal是在app的 DOM节点之下的,父节点的dom结构和css都会给modal产生影响</p>
<p>于是产生的问题</p>
<ol>
<li>
<p>modal被包裹在其它组件之中，容易被干扰</p>
</li>
<li>
<p>样式也在其它组件中，容易变得非常混乱</p>
</li>
</ol>
<p>Teleport 可以把modal组件渲染到任意你想渲染的外部Dom上,不必嵌套在#app中,这样就可以互不干扰了,可以把Teleport看成一个传送门,把你的组件传送到任何地方</p>
<p>使用的时候 to属性可以确定想要挂载的DOM节点下面</p>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;teleport to=&#34;#modal&#34;&gt;
    &lt;div id=&#34;center&#34;&gt;
      &lt;h2&gt;夏明&lt;/h2&gt;
    &lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre><p>在public文件夹下的index.html中增加一个节点</p>
<pre tabindex="0"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
  &lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34;&gt;
    &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1.0&#34;&gt;
    &lt;link rel=&#34;icon&#34; href=&#34;&lt;%= BASE_URL %&gt;favicon.ico&#34;&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      &lt;strong&gt;We&#39;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;
    &lt;/noscript&gt;
    &lt;div id=&#34;app&#34;&gt;&lt;/div&gt;
    &lt;div id=&#34;modal&#34;&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这样可以看到modal组件就是没有挂载在app下,不再受app组件的影响了</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://xiaming.com.cn/post/m1-mac-web-development-environment/"><span>←</span><span>M1 Mac搭建前端开发环境</span></a>
     
    <a class="next" href="https://xiaming.com.cn/post/nvm-command/"><span>nvm常用命令</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2014 - 2022 <a href="https://xiaming.com.cn/">夏明</a></p>
  <p><a href="/about/">关于</a></p>
</footer>

  </body>
</html>
